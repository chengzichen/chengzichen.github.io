# Shell

shell简化管理员的工作
## Bash变量

- 变量与java中的变量是一样的命名
- 变量不能超过256


shell中变量默认都是字符串

变量类型可以分为:

- 字符型
- 浮点型
- 整型
- 日期型


用户自定义的变量,环境变量,位置参数变量,预定义变量


## 用户自定义变量
注意:=两边不能有空格,定义和java中差不多,变量默认是字符串,不能做数学运算
- 变量在同一环境中只有一个
- 变量叠加: x="$x"456
- set : 查看shell中正在使用的变量 # 选项 -u ,区别变量是否存在
- unset : 删除的是变量,不是变量值


## 环境变量
全局变量
- pstree 查看当前的bash的个数
- export 变量名=变量值  或者  变量名=变量值 再 export 变量名
- set 查看所有的变量
- env 查看环境变量

系统定义好的环境变量:
- HOSTNAME :主机名
- SHELL : 当前的shell
- TERM : 终端环境
- HISTSIZE :历史命令条数
- SSH_CLIENT :当前操作环境是用的是ssh连接的,记录来了客户端的ip
- SSH_TTY : ssh连接的终端是pts/1
- USER: 当前登陆的用户
- PATH :是指系统搜索命令的路径
- PATH="$PATH":/root    #表示吧/root路径加入到PATH路径中去
- PS1的用处:命令行前面用于修改前面提示的状态
- 可以修改
语系变量:
- locale 查看  当前系统语系   - LANG: 定义系统主语系的变量   -LC_ALL :定义整体语系的变量 
- echo $LANG  #查看系统当前语系
- locale -a | more  # 查看Linux支持的所有语系
默认语系环境
- 是重启之后的默认语系环境
- linux支持中文支持: 中文字体,中文语系zhcon
- 纯字符界面不能显示中文,如果需要的话使用的第三方插件

## 位置参数变量

#!/bin/bash

num1=$1
num2=$2
sum2=(($num1 + $num2))

echo $sum2

加上权限

chmod 755 test.sh 

运行

./test.sh  12 12


这里其中num1=$1 num2=$2 这就是位置参数变量

这里只能编程员自己来用

- $n  n为数字 $0表示命令的本身,$1-9上了10需要${10}表示
- $\* :这个变量代表命令行中所有的参数 ,$\* 会吧所有参数看做为一个参数
- $@ 这个变量也代表命令行中所有的参数,不过$@把每个参数分别对待
- $# 返回参数的数数量

## 预定义变量
- echo -e  "\n"  表示换行
- $? #是否正确,最后一次执行的命令的返回状态,如果
- $$ : 表示当前运行的进程
- $! : 返回后台进程 

- read [选项] [变量名]

选项  
- -p  : 提示:在等待read输入时,输出提示信息
- -t秒数  ：read 命令一直等待用户输入,使用此选项可以指定等待时间 
- -s 隐藏输入的数据,适用于机密信息的 输入
- -n read命令直接受指定的字符数,就会执行

## shell运算符
shell变量的缺点:
- 弱类型
- 默认字符串型


## shell运算符

declare 声明
declare [+/-] [选项]  变量

选项:
- +表示取消变量属性
- -表示添加变量属性
- -a : 数组
- -i :整数
- -x :将变量声明为环境变量
- -r :只读变量
- -p :显示被指定的变量类型,
- declare -i cc=$aa + $bb #声明数值变量
- declare -a movie[0]=iu   #声明数组也可以是直接用 movie[0]=io 表示声明数组,调用时使用echo ${movie[*]}方式表示,movie[1],那么movie[0]默认值会是空
- declare -x test=123 声明环境变量
#和export 作用相相似,但是最终执行的还是declare 

- 运算 declare -i cc=$aa+$bb
- 或者 cc=$((aa+bb))这里省略了$ cc=$(($aa+$bb))

运算符是有优先级的

## 变量测试

- x=${y-新值}  ,y不存在x=新值,y=空x=空,y=1 x=1


## 环境变量配置文件

简介
    
- source 配置文件  # 重新加载设置配置文件
- .  配置文件  # 重新加载设置配置文件

配置文件
- /etc/profile # 配置PATH等环境变量
- /ect/profile.d/*.sh  #->>lang.sh->>ect/sysc cogfig/i18n  来加载语系
- ~/.bash_profile
- ~/.bashrc
- /ect/bashrc

在~ 目录下的配置只对当前用户起作用
在/目录下

- umask  查看系统默认的权限

- 文件的最高权限是666
- 目录的最高权限是777
- 因为文件被创建是不能被执行,必须被root用户赋予执行权限才能执行
- umask定义的权限,是系统默认需要丢弃的权限  所以是-w--w- ,0022

```
目录最高权限    umask权限   创建的目录权限

rwxrwxrwx          ----w--w-      ==>  rwxr-xr-x

777                           022                  755

文件最高权限  umask权限    创建的文件权限

rw-rw-rw-          ----w--w-      ==> rw-r--r--

666                        022                    6 44
```
这里的权限计算并不是数字减出来的,而是使用上面法则计算出来的


## 正则



## 拓展

- etc不是什么缩写，是and so on的意思 来源于 法语的 et cetera 翻译成中文就是 等等 的意思. 至于为什么在/etc下面存放配置文件， 按照原始的UNIX的说法(linux文件结构参考UNIX的教学实现MINIX) 这下面放的都是一堆零零碎碎的东西, 就叫etc, 这其实是个历史遗留.

- rc "rc" (像是 ".cshrc" 或 "/etc/rc" 中的 rc 这两个字母) = "RunCom"　 
"rc" 是取自 "runcom", 来自麻省理工学院在 1965 年发展的 CTSS系统。相关文献曾记载这一段话："具有从档案中取出一系列命令来执行的功能；这称为 "run commands" 又称为 "runcom"，而这种档案又称为一个 runcom (a runcom)。"

- 由于su 对切换到超级权限用户root后，权限的无限制性，所以su并不能担任多个管理员所管理的系统。如果用su 来切换到超级用户来管理系统，也不能明确哪些工作是由哪个管理员进行的操作。特别是对于服务器的管理有多人参与管理时，最好是针对每个管理员的技术特长和管理范围，并且有针对性的下放给权限，并且约定其使用哪些工具来完成与其相关的工作，这时我们就有必要用到 sudo


http://blog.csdn.net/ruancoder/article/details/52246074